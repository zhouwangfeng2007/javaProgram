<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<META NAME="ROBOTS" CONTENT="NOINDEX,NOFOLLOW">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<title>mybatis+spring+springmvc（传智播客）笔记;- </title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>南京廖华答案网</o:Author>
  <o:LastAuthor>南京廖华答案网</o:LastAuthor>
  <o:Revision>6</o:Revision>
  <o:TotalTime>59</o:TotalTime>
  <o:Created>2020/6/23 23:35:26</o:Created>
  <o:LastSaved>2020/6/23 23:35:26</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>101</o:Words>
  <o:Characters>576</o:Characters>
  <o:Company>南京廖华答案网</o:Company>
  <o:Lines>4</o:Lines>
  <o:Paragraphs>1</o:Paragraphs>
  <o:CharactersWithSpaces>676</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:View>Print</w:View>
  <w:PunctuationKerning/>
  <w:DrawingGridVerticalSpacing>7.8 磅</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:AdjustLineHeightInTable/>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
   <w:UseFELayout/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:16.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
h1
	{mso-style-next:正文;
	margin-top:17.0pt;
	margin-right:0cm;
	margin-bottom:16.5pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:240%;
	mso-pagination:lines-together;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:22.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:22.0pt;
	font-weight:bold;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:none;
	tab-stops:center 207.65pt right 415.3pt;
	layout-grid-mode:char;
	border:none;
	mso-border-bottom-alt:solid windowtext .75pt;
	padding:0cm;
	mso-padding-alt:0cm 0cm 1.0pt 0cm;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:none;
	tab-stops:center 207.65pt right 415.3pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:宋体;
	mso-bidi-font-family:宋体;}
 /* Page Definitions */
 @page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;
@page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 89.85pt 72.0pt 89.85pt;
	mso-header-margin:42.55pt;
	mso-footer-margin:42.55pt;
	mso-paper-source:0;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=ZH-CN link=blue vlink=purple style='tab-interval:21.0pt;text-justify-trim:punctuation'>

<div class=Section1 style='layout-grid:15.6pt'>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span style='font-size:12.0pt;font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";color:#993300'>《mybatis+spring+springmvc（传智播客）笔记;- 》来自南京廖华答案网</span></b><b
style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:12.0pt;color:#993300'><o:p></o:p></span></b></p>

<p class=MsoNormal align=left style='text-align:left;line-height:150%;margin-top:3.6pt;'><span lang=EN-US style='font-size:9.0pt;line-height:150%'><a href="http://www.32336.cn/lhs_03103d02q02p03802x03701703703403602x03202v01703703403602x03202v03103a02r014fmok8qjvxi3m015ob8rlc01n01900w_0.html"><span lang=EN-US style='font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";text-decoration:none;text-underline:none'><span lang=EN-US>点这里，有很多篇《mybatis+spring+springmvc(传智播客)笔记;- 》</span></span></a><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left'><span style='font-size:12.0pt;font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";color:#993300'>在线阅读本文：</span><span lang=EN-US style='font-size:12.0pt;color:#999999'><a href="http://www.32336.cn/lhd_5vyfr737hm86wqu5roq73pebe0io3700log_1.html"><span
style='text-decoration:none;text-underline:none'>http://www.32336.cn/lhd_5vyfr737hm86wqu5roq73pebe0io3700log_1.html</span></a><o:p></o:p></span></p>

<p class=MsoNormal align=center style='margin-top:15.6pt;margin-right:0cm;margin-bottom:23.4pt;margin-left:0cm;mso-para-margin-top:1.0gd;mso-para-margin-right:
0cm;mso-para-margin-bottom:1.5gd;mso-para-margin-left:0cm;text-align:center'><b style='mso-bidi-font-weight:normal'><span style='font-size:22.0pt;font-family:
宋体'>mybatis+spring+springmvc(传智播客)笔记;- <span lang=EN-US><o:p></o:p></span></span></b></p>

<div style='margin-top:2.5pt;margin-bottom:2.5pt'>

<div style='margin-top:7.8pt;margin-right:0cm;margin-bottom:12.45pt;margin-left:0cm;mso-para-margin-top:.5gd;mso-para-margin-right:0cm;mso-para-margin-bottom:.5gd;mso-para-margin-left:0cm;text-align:justify;text-justify:inter-ideograph;text-indent:32.0pt;mso-char-indent-count:2.0;line-height:22.0pt;mso-line-height-rule:exactly;mso-pagination:none;font-size:16.0pt;mso-bidi-font-family:"Times New Roman";mso-font-kerning:1.0pt'><p>javaEE框架课程   </p><p> </p><p> </p><p>Mybatis </p><p> </p><p>框架课程 </p><p>                            </p><p>javaEE框架课程   </p><p>1 Mybatis入门 </p><p>1.1 单独使用jdbc编程问题总结 1.1.1 jdbc程序 </p><p>Publicstaticvoid main(String[] args) {    Connection connection = null; </p><p>   PreparedStatement preparedStatement = null;    ResultSet resultSet = null;     </p><p>   try {    </p><p>   </p><p>   </p><p>   </p><p>//加载数据库驱动 </p><p>Class.forName(\);  </p><p>    //通过驱动管理类获取数据库链接     connection =  </p><p>DriverManager.getConnection(\terEncoding=utf-8\, \, \);    </p><p>    </p><p>    </p><p>    </p><p>//定义sql语句 ?表示占位符 </p><p>String sql = \; //获取预处理statement </p><p>preparedStatement = connection.prepareStatement(sql); </p><p>    //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 </p><p>    preparedStatement.setString(1, \王五\);     //向数据库发出sql执行查询，查询出结果集 </p><p>    resultSet =  preparedStatement.executeQuery();     //遍历查询结果集 </p><p>    while(resultSet.next()){ </p><p>     System.out.println(resultSet.getString(\)+\\+resultSet.getString(\));     } </p><p>   } catch (Exception e) {     e.printStackTrace();    }finally{      </p><p>     </p><p>     </p><p>     </p><p>//释放资源 </p><p>if(resultSet!=null){  try { </p><p>  resultSet.close(); </p><p> } catch (SQLException e) { </p><p>javaEE框架课程   </p><p>                         </p><p>                      </p><p>                     } </p><p>                    } </p><p>  // TODO Auto-generated catch block   e.printStackTrace();  } } </p><p>if(preparedStatement!=null){  try { </p><p>  preparedStatement.close();  } catch (SQLException e) { </p><p>  // TODO Auto-generated catch block   e.printStackTrace();  } } </p><p>if(connection!=null){  try { </p><p>  connection.close();  } catch (SQLException e) { </p><p>  // TODO Auto-generated catch block   e.printStackTrace();  } } </p><p>上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。 </p><p>1.1.2 jdbc编程步骤： </p><p>1、 加载数据库驱动 </p><p>2、 创建并获取数据库链接 3、 创建jdbc statement对象 4、 设置sql语句 </p><p>5、 设置sql语句中的参数(使用preparedStatement) 6、 通过statement执行sql并获取结果 7、 对sql执行结果进行解析处理 </p><p>8、 释放资源(resultSet、preparedstatement、connection)  </p><p>1.1.3 jdbc问题总结如下： </p><p>1、 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接</p><p>池可解决此问题。 </p><p>javaEE框架课程   </p><p>2、 Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动</p><p>需要改变java代码。 </p><p>3、 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不</p><p>一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 4、 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如</p><p>果能将数据库记录封装成pojo对象解析比较方便。  </p><p>1.2 MyBatis介绍 </p><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。 </p><p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 </p><p>Mybatis通过xml或注解的方式将要执行的各种statement（statement、</p><p>preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。  </p><p> </p><p>1.3 Mybatis架构 </p><p> </p><p> </p><p> </p><p>javaEE框架课程   </p><p>1、 mybatis配置 SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。 mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。  </p><p>2、 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 </p><p>3、 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。 4、 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个</p><p>是基本执行器、一个是缓存执行器。 </p><p>5、 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql</p><p>映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 </p><p>6、 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor</p><p>通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 7、 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor</p><p>通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。  </p><p>1.4 mybatis下载 </p><p>mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/releases  </p><p> </p><p>mybatis-3.2.7.jar----mybatis的核心包 lib----mybatis的依赖包 </p><p>mybatis-3.2.7.pdf----mybatis使用手册  </p><p>1.5 创建mysql数据库 </p><p>先导入sql_table.sql，再导入sql_data.sql脚本： </p><p>javaEE框架课程   </p><p> </p><p> 如下： </p><p> </p><p>  </p><p>1.6 Mybatis入门程序 </p><p> </p><p>1.6.1 需求 </p><p>实现以下功能： </p><p>根据用户id查询一个用户信息 </p><p>根据用户名称模糊查询用户信息列表 添加用户 更新用户 删除用户  </p><p>1.6.2 第一步：创建java工程 </p><p>使用eclipse创建java工程，jdk使用1.7.0_72。 </p><p>1.6.3 第二步：加入jar包 </p><p>加入mybatis核心包、依赖包、数据驱动包。 </p><p>javaEE框架课程   </p><p> </p><p> </p><p>1.6.4 第三步：log4j.properties </p><p>在classpath下创建log4j.properties如下：  </p><p># Global logging configuration log4j.rootLogger=DEBUG, stdout # Console output... </p><p>log4j.appender.stdout=org.apache.log4j.ConsoleAppender </p><p>log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n  </p><p>mybatis默认使用log4j作为输出日志信息。  </p><p>1.6.5 第四步：SqlMapConfig.xml </p><p>在classpath下创建SqlMapConfig.xml，如下：  </p><p><?xmlversion=\encoding=\?> <!DOCTYPEconfiguration </p><p>PUBLIC\ </p><p>\> <configuration> </p><p> <!-- 和spring整合后 environments配置将废除-->  <environmentsdefault=\>   <environmentid=\>   <!-- 使用jdbc事务管理--> </p><p>   <transactionManagertype=\/>   <!-- 数据库连接池--> </p><p>   <dataSourcetype=\>    </p><p>javaEE框架课程   </p><p> <propertyname=\value=\/>    </p><p> <propertyname=\value=\is?characterEncoding=utf-8\/> </p><p>    <propertyname=\value=\/>     <propertyname=\value=\/>    </dataSource>   </environment>  </environments>   </p><p></configuration> </p><p> </p><p>SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。 </p><p>1.6.6 第五步：po类 </p><p> </p><p>Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，User.java如下：  </p><p>PublicclassUser {  privateintid; </p><p> private String username;// 用户姓名  private String sex;// 性别  private Date birthday;// 生日  private String address;// 地址 get/set……  </p><p>1.6.7 第六步：程序编写 </p><p>1.6.7.1 查询 </p><p> </p><p>1.6.7.1.1 映射文件： </p><p>在classpath下的sqlmap目录下创建sql映射文件Users.xml：  </p><p><?xmlversion=\encoding=\?> <!DOCTYPEmapper </p><p>PUBLIC\ </p><p>javaEE框架课程   </p><p>\> </p><p><mappernamespace=\> </mapper>  </p><p>namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。   </p><p>在SqlMapConfig.xml中添加： <!-- 根据id获取用户信息 --> </p><p> <selectid=\parameterType=\resultType=\atis.po.User\> </p><p>  select * from userwhere id = #{id}  </select> </p><p> <!-- 自定义条件查询用户列表 --> </p><p> <selectid=\parameterType=\    resultType=\> </p><p>    select * from userwhere username like '%${value}%'   </select>  </p><p>parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设</p><p>置占位符号并将输入变量id传到sql。 </p><p>resultType：定义结果映射类型。  </p><p>1.6.7.1.2 加载映射文件 </p><p>mybatis框架需要加载映射文件，将Users.xml添加在SqlMapConfig.xml，如下：  </p><p><mappers> </p><p>  <mapperresource=\/> </mappers>   </p><p>1.6.7.1.3 测试程序： </p><p> </p><p>publicclass Mybatis_first {       </p><p>//会话工厂 </p><p>private SqlSessionFactory sqlSessionFactory; @Before </p><p>javaEE框架课程   </p><p>     </p><p>publicvoid createSqlSessionFactory() throws IOException {    </p><p>// 配置文件 </p><p>String resource = \; InputStream inputStream = Resources.getResourceAsStream(resource); </p><p>  // 使用SqlSessionFactoryBuilder从xml配置文件中创建</p><p>SqlSessionFactory </p><p>  sqlSessionFactory = new SqlSessionFactoryBuilder()     .build(inputStream);  </p><p> }  </p><p>// 根据 id查询用户信息  @Test </p><p> publicvoid testFindUserById() {   // 数据库会话实例 </p><p>  SqlSession sqlSession = null;   try { </p><p>   // 创建数据库会话实例sqlSession </p><p>   sqlSession = sqlSessionFactory.openSession();    // 查询单个记录，根据用户id查询用户信息 </p><p>   Useruser = sqlSession.selectOne(\, 10); </p><p>   // 输出用户信息 </p><p>   System.out.println(user);   } catch (Exception e) {    e.printStackTrace();   } finally { </p><p>   if (sqlSession != null) {     sqlSession.close();    }   }  </p><p> }  </p><p> // 根据用户名称模糊查询用户信息  @Test </p><p> publicvoid testFindUserByUsername() {   // 数据库会话实例 </p><p>  SqlSession sqlSession = null;   try { </p><p>   // 创建数据库会话实例sqlSession </p><p>   sqlSession = sqlSessionFactory.openSession();    // 查询单个记录，根据用户id查询用户信息 </p><p> </p><p>javaEE框架课程   </p><p>   List<User> list = </p><p>sqlSession.selectList(\, \张\);    System.out.println(list.size());   } catch (Exception e) {    e.printStackTrace();   } finally { </p><p>   if (sqlSession != null) {     sqlSession.close();    }   }  </p><p> } </p><p>}  </p><p>1.6.7.1.4 #{}和${} </p><p>#{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。  </p><p>${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换，${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。   </p><p>1.6.7.1.5 parameterType和resultType </p><p>parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 </p><p>resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。  </p><p>1.6.7.1.6 selectOne和selectList </p><p> </p><p>selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： </p><p>org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3  at </p><p>javaEE框架课程   </p><p>org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70)  </p><p>selectList可以查询一条或多条记录。  </p><p>1.6.7.2 添加 </p><p>1.6.7.2.1 映射文件： </p><p>在SqlMapConfig.xml中添加： <!-- 添加用户 --> </p><p> <insertid=\parameterType=\>  <selectKeykeyProperty=\order=\resultType=\\> </p><p>  select LAST_INSERT_ID()   </selectKey> </p><p> insert into user(username,birthday,sex,address)     values(#{username},#{birthday},#{sex},#{address})  </insert>  </p><p>1.6.7.2.2 测试程序： </p><p>// 添加用户信息  @Test </p><p> publicvoid testInsert() {                </p><p>               </p><p>// 数据库会话实例 </p><p>SqlSession sqlSession = null; try {          </p><p>// 创建数据库会话实例sqlSession </p><p>sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 </p><p>Useruser =new User(); </p><p>user.setUsername(\张小明\); user.setAddress(\河南郑州\); user.setSex(\); </p><p>user.setPrice(1999.9f); </p><p>sqlSession.insert(\, user); </p><p> //提交事务 </p><p> sqlSession.commit(); } catch (Exception e) { </p><p>javaEE框架课程   </p><p>             } </p><p> e.printStackTrace(); } finally { </p><p> if (sqlSession != null) {   sqlSession.close();  } } </p><p>1.6.7.2.3 mysql自增主键返回 </p><p>通过修改sql映射文件，可以将mysql自增主键返回： </p><p><insertid=\parameterType=\>    \>      </p><p> </p><p><!-- selectKey将主键返回，需要再返回 --> </p><p><selectKeykeyProperty=\order=\AFTER\resultType=\  select LAST_INSERT_ID()  </selectKey> </p><p>insert into user(username,birthday,sex,address)     values(#{username},#{birthday},#{sex},#{address}); </insert> </p><p>添加selectKey实现将主键返回 </p><p>keyProperty:返回的主键存储在pojo中的哪个属性 </p><p>order：selectKey的执行顺序，是相对与insert语句来说，由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为after resultType:返回的主键是什么类型 </p><p>LAST_INSERT_ID():是mysql的函数，返回auto_increment自增列新记录id值。  </p><p>1.6.7.2.4 Mysql使用uuid实现主键 </p><p> </p><p>需要增加通过select uuid()得到uuid值  </p><p><insert id=\</p><p><selectKey resultType=\BEFORE\keyProperty=\select uuid() </selectKey> </p><p>insert into user(id,username,birthday,sex,address)     values(#{id},#{username},#{birthday},#{sex},#{address}) </insert> </p><p>注意这里使用的order是“BEFORE” </p><p>javaEE框架课程   </p><p>  </p><p>1.6.7.2.5 Oracle使用序列生成主键 </p><p>首先自定义一个序列且用于生成主键，selectKey使用如下： <insert id=\</p><p><selectKey resultType=\BEFORE\keyProperty=\</p><p>SELECT 自定义序列.NEXTVAL FROM DUAL </selectKey> </p><p>insert into user(id,username,birthday,sex,address)     values(#{id},#{username},#{birthday},#{sex},#{address}) </insert> </p><p>注意这里使用的order是“BEFORE” </p><p>1.6.7.3 删除 </p><p>1.6.7.3.1 映射文件： </p><p> </p><p><!-- 删除用户 --> </p><p> <deleteid=\parameterType=\>   delete from userwhere id=#{id}  </delete>   </p><p>1.6.7.3.2 测试程序： </p><p> </p><p>// 根据id删除用户  @Test </p><p> publicvoidtestDelete() {        </p><p>       </p><p>// 数据库会话实例 </p><p>SqlSession sqlSession = null; try {     </p><p>// 创建数据库会话实例sqlSession </p><p>sqlSession = sqlSessionFactory.openSession(); // 删除用户 </p><p>sqlSession.delete(\,18); </p><p>javaEE框架课程   </p><p>                   } </p><p> // 提交事务 </p><p> sqlSession.commit(); } catch (Exception e) {  e.printStackTrace(); } finally { </p><p> if (sqlSession != null) {   sqlSession.close();  } } </p><p>1.6.7.4 修改 1.6.7.4.1 映射文件 </p><p> </p><p><!-- 更新用户 --> </p><p> <updateid=\parameterType=\>   update userset </p><p>username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}   where id=#{id} </p><p> </update>  </p><p>1.6.7.4.2 测试程序 </p><p> </p><p>// 更新用户信息  @Test </p><p> publicvoidtestUpdate() {             </p><p>            </p><p>// 数据库会话实例 </p><p>SqlSession sqlSession = null; try {          </p><p>// 创建数据库会话实例sqlSession </p><p>sqlSession = sqlSessionFactory.openSession(); // 添加用户信息 </p><p>Useruser =new User(); user.setId(16); </p><p>user.setUsername(\张小明\); user.setAddress(\河南郑州\); user.setSex(\); </p><p>user.setPrice(1999.9f); </p><p>javaEE框架课程   </p><p>              </p><p>          } </p><p>   </p><p>sqlSession.update(\, user); // 提交事务 </p><p>sqlSession.commit(); </p><p>} catch (Exception e) {  e.printStackTrace(); } finally { </p><p> if (sqlSession != null) {   sqlSession.close();  } } </p><p>1.6.8 Mybatis解决jdbc编程的问题 </p><p>1、 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接</p><p>池可解决此问题。 </p><p>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。 </p><p>2、 Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改</p><p>变java代码。 </p><p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。 </p><p>3、 向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符</p><p>需要和参数一一对应。 </p><p>解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 </p><p>4、 对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库</p><p>记录封装成pojo对象解析比较方便。 </p><p>解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。   </p><p>1.6.9 与hibernate不同 </p><p>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。  </p><p>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是</p><p>javaEE框架课程   </p><p>mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。  </p><p>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 </p><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。    </p><p>2 Dao开发方法 </p><p> 使用Mybatis开发Dao，通常有两个方法，即原始Dao开发方法和Mapper接口开发方法。  </p><p>2.1 需求 </p><p>将下边的功能实现Dao： </p><p>根据用户id查询一个用户信息 </p><p>根据用户名称模糊查询用户信息列表 添加用户信息  </p><p>2.2 SqlSession的使用范围 </p><p> SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。 </p><p>通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。  </p><p>2.2.1 SqlSessionFactoryBuilder </p><p>SqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。  </p><p>javaEE框架课程   </p><p>2.2.2 SqlSessionFactory </p><p> SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。  </p><p>2.2.3 SqlSession </p><p> SqlSession是一个面向用户的接口，sqlSession中定义了数据库操作，默认使用DefaultSqlSession实现类。  </p><p>执行过程如下： </p><p>1、 加载数据源等配置信息 </p><p>Environment environment = configuration.getEnvironment(); </p><p>2、 创建数据库链接 3、 创建事务对象 </p><p>4、 创建Executor，SqlSession所有操作都是通过Executor完成，mybatis源码如下：  </p><p>if (ExecutorType.BATCH == executorType) { </p><p>      executor = newBatchExecutor(this, transaction);     } elseif (ExecutorType.REUSE == executorType) {       executor = new ReuseExecutor(this, transaction);     } else { </p><p>      executor = new SimpleExecutor(this, transaction);     } </p><p>if (cacheEnabled) { </p><p>      executor = new CachingExecutor(executor, autoCommit);     }  </p><p>5、 SqlSession的实现类即DefaultSqlSession，此对象中对操作数据库实质上用的是Executor  </p><p>结论：  每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。  打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。如下：  SqlSession session = sqlSessionFactory.openSession();  try {    // do work  } finally {   session.close(); </p><p>javaEE框架课程   </p><p>   </p><p>} </p><p>2.3 原始Dao开发方式 </p><p> </p><p>原始Dao开发方法需要程序员编写Dao接口和Dao实现类。 </p><p>2.3.1 映射文件 </p><p><?xmlversion=\encoding=\?> <!DOCTYPEmapper </p><p>PUBLIC\ </p><p>\> <mappernamespace=\> </p><p><!-- 根据id获取用户信息 --> </p><p> <selectid=\parameterType=\resultType=\atis.po.User\> </p><p>  select * from userwhere id = #{id}  </select> </p><p><!-- 添加用户 --> </p><p> <insertid=\parameterType=\>  <selectKeykeyProperty=\order=\resultType=\\> </p><p>  select LAST_INSERT_ID()   </selectKey> </p><p> insert into user(username,birthday,sex,address)     values(#{username},#{birthday},#{sex},#{address})  </insert> </mapper>   </p><p>2.3.2 Dao接口 </p><p>Publicinterface UserDao { </p><p> publicUser getUserById(int id) throws Exception;  publicvoid insertUser(Useruser)throws Exception; }  </p><p>Publicclass UserDaoImpl implements UserDao {   </p><p>javaEE框架课程   </p><p>             数                     }  </p><p>//注入SqlSessionFactory </p><p>public UserDaoImpl(SqlSessionFactory sqlSessionFactory){  this.setSqlSessionFactory(sqlSessionFactory); }  </p><p>private SqlSessionFactory sqlSessionFactory; @Override </p><p>public UsergetUserById(int id) throws Exception { </p><p> SqlSession session = sqlSessionFactory.openSession();  Useruser =null;  try {   </p><p>  </p><p>//通过sqlsession调用selectOne方法获取一条结果集 </p><p>//参数1：指定定义的statement的id,参数2：指定向statement中传递的参</p><p>  user = session.selectOne(\, 1);   System.out.println(user);        } finally{ </p><p>  session.close();  } </p><p> returnuser; }  </p><p>@Override </p><p>Publicvoid insertUser(Useruser)throws Exception { </p><p> SqlSession sqlSession= sqlSessionFactory.openSession();  try { </p><p>  sqlSession.insert(\, user);   sqlSession.commit();  } finally{ </p><p>  session.close();  }   } </p><p>2.3.3 问题 </p><p>原始Dao开发中存在以下问题： </p><p>? Dao方法体存在重复代码：通过SqlSessionFactory创建SqlSession，调用SqlSession的数</p><p>据库操作方法 </p><p>? 调用sqlSession的数据库操作方法需要指定statement的id，这里存在硬编码，不</p><p>得于开发维护。 </p><p>javaEE框架课程   </p><p> </p><p>2.4 Mapper动态代理方式  2.4.1 实现原理 </p><p> Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 </p><p>Mapper接口开发需要遵循以下规范： </p><p>1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。 </p><p>2、  Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 </p><p>3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的</p><p>类型相同 </p><p>4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相</p><p>同 </p><p>2.4.2 Mapper.xml(映射文件) </p><p> 定义mapper映射文件UserMapper.xml（内容同Users.xml），需要修改namespace的值为UserMapper接口路径。将UserMapper.xml放在classpath 下mapper目录下。  </p><p><?xmlversion=\encoding=\?> <!DOCTYPEmapper </p><p>PUBLIC\ </p><p>\> </p><p><mappernamespace=\cn.itcast.mybatis.mapper.UserMapper\> </p><p><!-- 根据id获取用户信息 --> </p><p> <selectid=\parameterType=\resultType=\atis.po.User\> </p><p>  select * from userwhere id = #{id}  </select> </p><p><!-- 自定义条件查询用户列表 --> </p><p> <selectid=\parameterType=\    resultType=\> </p><p>    select * from user where username like '%${value}%'   </select> </p><p><!-- 添加用户 --> </p><p> <insertid=\parameterType=\>  <selectKeykeyProperty=\order=\resultType=\\> </p><p>  select LAST_INSERT_ID()  </p><p>javaEE框架课程   </p><p> </selectKey> </p><p>   insert into user(username,birthday,sex,address)     values(#{username},#{birthday},#{sex},#{address})  </insert>  </p><p></mapper>  </p><p>2.4.3 Mapper.java(接口文件) </p><p> /** </p><p> * 用户管理mapper  */ </p><p>Publicinterface UserMapper {       }  </p><p>//根据用户id查询用户信息 </p><p>publicUser findUserById(int id) throws Exception; </p><p>//查询用户列表 public List<User> findUserByUsername(String username) throws Exception; //添加用户信息 </p><p>publicvoid insertUser(Useruser)throws Exception;  </p><p>接口定义有如下特点： </p><p>1、 Mapper接口方法名和Mapper.xml中定义的statement的id相同 </p><p>2、 Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的</p><p>类型相同 </p><p>3、 Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型</p><p>相同  </p><p>2.4.4 加载UserMapper.xml文件 </p><p>修改SqlMapConfig.xml文件：  </p><p><!-- 加载映射文件 --> <mappers> </p><p><mapperresource=\/> </mappers> </p><p>  </p><p>javaEE框架课程   </p><p>2.4.5 测试 </p><p> </p><p>Publicclass UserMapperTest extends TestCase {  </p><p> private SqlSessionFactory sqlSessionFactory;   </p><p> protectedvoid setUp() throws Exception {    </p><p>   </p><p>//mybatis配置文件 </p><p>String resource = \; InputStream inputStream = Resources.getResourceAsStream(resource); </p><p>  //使用SqlSessionFactoryBuilder创建sessionFactory </p><p>  sqlSessionFactory = new </p><p>SqlSessionFactoryBuilder().build(inputStream);  }    </p><p> Publicvoid testFindUserById() throws Exception {                </p><p>       </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //调用代理对象方法 </p><p>Useruser = userMapper.findUserById(1); System.out.println(user); </p><p> //关闭session  session.close();   } </p><p>@Test </p><p>publicvoid testFindUserByUsername() throws Exception { </p><p> SqlSession sqlSession = sqlSessionFactory.openSession(); </p><p> UserMapper userMapper = sqlSession.getMapper(UserMapper.class); </p><p>  List<User> list = userMapper.findUserByUsername(\张\);   System.out.println(list.size());  </p><p> } </p><p>Publicvoid testInsertUser() throws Exception {       </p><p>      </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口的代理对象 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //要添加的数据 </p><p>Useruser =new User(); </p><p>javaEE框架课程   </p><p>             }  </p><p>        </p><p>user.setUsername(\张三\); </p><p>user.setBirthday(new Date()); user.setSex(\); </p><p>user.setAddress(\北京市\); //通过mapper接口添加用户 </p><p>userMapper.insertUser(user); //提交 </p><p>session.commit(); </p><p> //关闭session  session.close(); }  </p><p>2.4.6 总结 </p><p>? selectOne和selectList </p><p>动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。  </p><p>? namespace </p><p>mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。   </p><p>3 SqlMapConfig.xml配置文件 </p><p>3.1 配置内容 </p><p>SqlMapConfig.xml中配置的内容和顺序如下： </p><p> </p><p>properties（属性） </p><p>settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） </p><p>javaEE框架课程   </p><p>environments（环境集合属性对象） </p><p>environment（环境子属性对象） </p><p>transactionManager（事务管理） dataSource（数据源） </p><p>mappers（映射器）  </p><p>3.2 properties（属性） </p><p> </p><p>SqlMapConfig.xml可以引用java属性文件中的配置信息如下：  </p><p>在classpath下定义db.properties文件， jdbc.driver=com.mysql.jdbc.Driver </p><p>jdbc.url=jdbc:mysql://localhost:3306/mybatis jdbc.username=root jdbc.password=mysql   </p><p>SqlMapConfig.xml引用如下：  </p><p><propertiesresource=\db.properties\/>  <environmentsdefault=\>   <environmentid=\> </p><p>   <transactionManagertype=\/>    <dataSourcetype=\> </p><p>    <propertyname=\value=\${jdbc.driver}\/>     <propertyname=\value=\${jdbc.url}\/> </p><p>    <propertyname=\value=\${jdbc.username}\/>     <propertyname=\value=\${jdbc.password}\/>    </dataSource>   </environment>  </environments>  </p><p>注意： MyBatis 将按照下面的顺序来加载属性： ? 在properties 元素体内定义的属性首先被读取。 </p><p>? 然后会读取properties 元素中resource或 url加载的属性，它会覆盖已读取的同名属性。 ? 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。  </p><p>因此，通过parameterType传递的属性具有最高优先级，resource或 url 加载的属性次之，最低优先级的是properties 元素体内定义的属性。   </p><p>javaEE框架课程   </p><p>3.3 settings（配置） </p><p>mybatis全局配置参数，全局参数将会影响mybatis的运行行为。  </p><p>详细参见“学习资料/mybatis-settings.xlsx”文件 </p><p> </p><p> </p><p> </p><p>   </p><p>javaEE框架课程   </p><p>3.4 typeAliases（类型别名） 3.4.1 mybatis支持别名： </p><p>别名 _byte  _long  _short  _int  _integer  _double  _float  _boolean  string  byte  long  short  int  integer  double  float  boolean  date  decimal  bigdecimal    </p><p>映射的类型 byte  long  short  int  int  double  float  boolean  String  Byte  Long  Short  Integer  Integer  Double  Float  Boolean  Date  </p><p>BigDecimal  BigDecimal  </p><p>3.4.2 自定义别名： </p><p>在SqlMapConfig.xml中配置： <typeAliases>     </p><p><!-- 单个别名定义 --> </p><p><typeAliasalias=\type=\/> </p><p><!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --> <packagename=\/> </p><p> <packagename=\其它包\/> </typeAliases>   </p><p>javaEE框架课程   </p><p>3.5 typeHandlers（类型处理器） </p><p>类型处理器用于java类型和jdbc类型映射，如下：  </p><p><selectid=\parameterType=\resultType=\>   select * from userwhere id = #{id} </select>  </p><p>mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。  </p><p>mybatis支持类型处理器：  </p><p>类型处理器 </p><p>BooleanTypeHandler  ByteTypeHandler  ShortTypeHandler  IntegerTypeHandler  LongTypeHandler  FloatTypeHandler  DoubleTypeHandler  BigDecimalTypeHandler  StringTypeHandler  ClobTypeHandler  NStringTypeHandler  NClobTypeHandler  ByteArrayTypeHandler  BlobTypeHandler  DateTypeHandler  DateOnlyTypeHandler  TimeOnlyTypeHandler  SqlTimestampTypeHandler  SqlDateTypeHandler  SqlTimeTypeHandler  ObjectTypeHandler  EnumTypeHandler  </p><p>Java类型 </p><p>Boolean，boolean  Byte，byte  Short，short  Integer，int  Long，long  Float，float  Double，double  BigDecimal  String  String  String  String  byte[]  byte[]  </p><p>Date（java.util） Date（java.util） Date（java.util） </p><p>Timestamp（java.sql） Date（java.sql） Time（java.sql） 任意 </p><p>Enumeration类型 </p><p>JDBC类型 </p><p>任何兼容的布尔值 </p><p>任何兼容的数字或字节类型 任何兼容的数字或短整型 任何兼容的数字和整型 任何兼容的数字或长整型 任何兼容的数字或单精度浮点型 </p><p>任何兼容的数字或双精度浮点型 </p><p>任何兼容的数字或十进制小数类型 </p><p>CHAR和VARCHAR类型 CLOB和LONGVARCHAR类型 </p><p>NVARCHAR和NCHAR类型 NCLOB类型 </p><p>任何兼容的字节流类型 BLOB和</p><p>LONGVARBINARY类型 TIMESTAMP类型 DATE类型 TIME类型 </p><p>TIMESTAMP类型 DATE类型 TIME类型 </p><p>其他或未指定类型 </p><p>VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引）。 </p><p> </p><p>javaEE框架课程   </p><p>3.6 mappers（映射器） </p><p>Mapper配置的几种方法： </p><p>3.6.1 <mapper resource=\</p><p>使用相对于类路径的资源 </p><p>如：<mapper resource=\ </p><p>3.6.2 <mapper url=\</p><p>使用完全限定路径 </p><p>如：<mapper url=\</p><p> </p><p>3.6.3 <mapper class=\</p><p>使用mapper接口类路径 </p><p>如：<mapper class=\ </p><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。  </p><p>3.6.4 <package name=\</p><p>注册指定包下的所有mapper接口 </p><p>如：<package name=\</p><p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。 </p><p>  </p><p>4 Mapper.xml映射文件 </p><p>Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。  </p><p>javaEE框架课程   </p><p>4.1 parameterType(输入类型) </p><p>4.1.1 #{}与${} </p><p>#{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?。  </p><p><!-- 根据id查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\>   select * from userwhere id = #{id}  </select> </p><p>使用占位符#{}可以有效防止sql注入，在使用时不需要关心参数值的类型，mybatis会自动进行java类型和jdbc类型的转换。#{}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。  </p><p>${}和#{}不同，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。使用${}不能防止sql注入，但是有时用${}会非常方便，如下的例子：  </p><p><!-- 根据名称模糊查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\>     select * from userwhere username like '%${value}%'  </select>  </p><p>如果本例子使用#{}则传入的字符串中必须有%号，而%是人为拼接在参数中，显然有点麻烦，如果采用${}在sql中拼接为%的方式则在调用mapper接口传递参数就方便很多。  </p><p>//如果使用占位符号则必须人为在传参数中加% </p><p>List<User> list = userMapper.selectUserByName(\管理员%\);   </p><p>//如果使用${}原始符号则不用人为在参数中加% </p><p>List<User>list = userMapper.selectUserByName(\管理员\);  </p><p>再比如order by排序，如果将列名通过参数传入sql，根据传的列名进行排序，应该写为： ORDER BY ${columnName} </p><p>如果使用#{}将无法实现此功能。   </p><p>javaEE框架课程   </p><p>4.1.2 传递简单类型 </p><p>参考上边的例子。 </p><p>4.1.3 传递pojo对象 </p><p> </p><p>Mybatis使用ognl表达式解析对象字段的值，如下例子：  </p><p><!―传递pojo对象综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\> </p><p>    select * from userwhere id=#{id} and username like '%${username}%'  </select>  </p><p>上边红色标注的是user对象中的字段名称。  </p><p>测试：  </p><p>Publicvoid testFindUserByUser()throws Exception{               </p><p>            } </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //构造查询条件user对象 Useruser =new User(); user.setId(1); </p><p>user.setUsername(\管理员\); //传递user对象查询用户列表 </p><p>List<User>list = userMapper.findUserByUser(user); //关闭session session.close(); </p><p>异常测试：  </p><p>Sql中字段名输入错误后测试，username输入dusername测试结果报错：  </p><p>org.apache.ibatis.exceptions.PersistenceException:  </p><p>### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'dusername' in 'class cn.itcast.mybatis.po.User' </p><p>### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'dusername' in 'class cn.itcast.mybatis.po.User'  </p><p>javaEE框架课程   </p><p>4.1.4 传递pojo包装对象 </p><p>  开发中通过pojo传递查询条件，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。  </p><p>4.1.4.1 定义包装对象 </p><p>定义包装对象将查询条件(pojo)以类组合的方式包装起来。  </p><p>publicclass QueryVo {   </p><p> privateUseruser;       </p><p>//自定义用户扩展类 </p><p>private UserCustom userCustom; </p><p>4.1.4.2 mapper.xml映射文件 </p><p> </p><p> </p><p>说明：mybatis底层通过ognl从pojo中获取属性值：#{user.username}，user即是传入的包装对象的属性。queryVo是别名，即上边定义的包装对象类型。   </p><p>4.1.5 传递hashmap </p><p>Sql映射文件定义如下： </p><p><!-- 传递hashmap综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\</p><p>javaEE框架课程   </p><p>\> </p><p>    select * from userwhere id=#{id} and username like '%${username}%'  </select>  </p><p>上边红色标注的是hashmap的key。  </p><p>测试： </p><p>Publicvoid testFindUserByHashmap()throws Exception{                 </p><p>             } </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //构造查询条件Hashmap对象 </p><p>HashMap<String, Object> map = new HashMap<String, Object>(); map.put(\, 1); </p><p>map.put(\, \管理员\);  </p><p>//传递Hashmap对象查询用户列表 </p><p>List<User>list = userMapper.findUserByHashmap(map); //关闭session session.close(); </p><p>异常测试： </p><p>传递的map中的key和sql中解析的key不一致。 测试结果没有报错，只是通过key获取值为空。   </p><p>4.2 resultType(输出类型) 4.2.1 输出简单类型 </p><p>参考getnow输出日期类型，看下边的例子输出整型：  </p><p>Mapper.xml文件 </p><p><!-- 获取用户列表总数 --> </p><p> <selectid=\parameterType=\resultType=\>     select count(1) from user  </select> </p><p> </p><p>Mapper接口 </p><p>javaEE框架课程   </p><p>public int findUserCount(Useruser) throws Exception; </p><p> </p><p>调用：  </p><p>Publicvoid testFindUserCount() throws Exception{                </p><p>            } </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获取mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); Useruser =new User(); user.setUsername(\管理员\); </p><p>//传递Hashmap对象查询用户列表 </p><p>intcount = userMapper.findUserCount(user);  </p><p>//关闭session session.close(); </p><p>总结： </p><p>输出简单类型必须查询出来的结果集有一条记录，最终将第一个字段的值转换为输出类型。 使用session的selectOne可查询单条记录。   </p><p>4.2.2 输出pojo对象 </p><p>参考findUserById的定义： Mapper.xml </p><p> <!-- 根据id查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\>   select * from userwhere id = #{id}  </select> </p><p>Mapper接口： </p><p>public UserfindUserById(int id) throws Exception;  </p><p>测试：  </p><p>Publicvoid testFindUserById() throws Exception {     </p><p>    </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); </p><p>javaEE框架课程   </p><p>      </p><p>     } </p><p>//通过mapper接口调用statement </p><p>Useruser = userMapper.findUserById(1); System.out.println(user); //关闭session session.close(); </p><p>使用session调用selectOne查询单条记录。    </p><p>4.2.3 输出pojo列表 </p><p> </p><p>参考selectUserByName的定义： Mapper.xml </p><p><!-- 根据名称模糊查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\\> </p><p>    select * from userwhere username like '%${value}%'  </select>    </p><p>Mapper接口：  </p><p>public List<User>findUserByUsername(String username) throws Exception;  </p><p>测试： </p><p>Publicvoid testFindUserByUsername()throws Exception{     </p><p>    </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); </p><p>  //如果使用占位符号则必须人为在传参数中加% </p><p>  //List<User> list = userMapper.selectUserByName(\管理员%\   //如果使用${}原始符号则不用人为在参数中加% </p><p>  List<User>list = userMapper.findUserByUsername(\管理员\);   //关闭session   session.close();  }   </p><p>使用session的selectList方法获取pojo列表。 </p><p>javaEE框架课程   </p><p> </p><p>4.2.4 resultType总结： </p><p>输出pojo对象和输出pojo列表在sql中定义的resultType是一样的。 </p><p>返回单个pojo对象要保证sql查询出来的结果集为单条，内部使用session.selectOne方法调用，mapper接口使用pojo对象作为方法返回值。  </p><p>返回pojo列表表示查询出来的结果集可能为多条，内部使用session.selectList方法，mapper接口使用List<pojo>对象作为方法返回值。   </p><p>4.2.5 输出hashmap </p><p>输出pojo对象可以改用hashmap输出类型，将输出的字段名称作为map的key，value为字段值。  </p><p>4.3 resultMap </p><p> resultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。  如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系，resultMap实质上还需要将查询结果映射到pojo对象中。  resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。   </p><p>4.3.1 Mapper.xml定义 </p><p> </p><p> </p><p>使用resultMap指定上边定义的personmap。 </p><p>javaEE框架课程   </p><p> </p><p>4.3.2 定义resultMap </p><p>由于上边的mapper.xml中sql查询列和Users.java类属性不一致，需要定义resultMap：userListResultMap将sql查询列和Users.java类属性对应起来  </p><p> </p><p> </p><p><id />：此属性表示查询结果集的唯一标识，非常重要。如果是多个字段为复合唯一约束则定义多个<id />。 </p><p>Property：表示person类的属性。 Column：表示sql查询出来的字段名。 </p><p>Column和property放在一块儿表示将sql查询出来的字段映射到指定的pojo类属性上。  </p><p><result />：普通结果，即pojo的属性。   </p><p>4.3.3 Mapper接口定义 </p><p> </p><p>public List<User>findUserListResultMap() throws Exception;    </p><p>4.4 动态sql(重点) </p><p>通过mybatis提供的各种标签方法实现动态拼接sql。  </p><p>javaEE框架课程   </p><p>4.4.1 If </p><p><!-- 传递pojo综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\>   select * from user   where 1=1  </p><p>  <iftest=\>   and id=#{id}   </if> </p><p>  <iftest=\>   and username like '%${username}%'   </if>  </select>  </p><p>注意要做不等于空字符串校验。   </p><p>4.4.2 Where </p><p>上边的sql也可以改为：  </p><p><selectid=\parameterType=\resultType=\>   select * from user   <where> </p><p>  <iftest=\>   and id=#{id}   </if> </p><p>  <iftest=\>   and username like '%${username}%'   </if>   </where>  </select>  </p><p><where />可以自动处理第一个and。   </p><p>4.4.3 foreach </p><p> </p><p>向sql传递数组或List，mybatis使用foreach解析，如下： </p><p>javaEE框架课程   </p><p> </p><p>4.4.3.1 通过pojo传递list </p><p> </p><p>? 需求 </p><p>传入多个id查询用户信息，用下边两个sql实现：  </p><p>SELECT * FROM USERS WHERE username LIKE '%张%' AND (id =10 OR id =89 OR id=16) SELECT * FROM USERS WHERE username LIKE '%张%'  id IN (10,89,16)  </p><p>? 在pojo中定义list属性ids存储多个用户id，并添加getter/setter方法 </p><p> </p><p> </p><p>? mapper.xml  </p><p><iftest=\> </p><p>  <foreachcollection=\open=\in(\close=\item=\separator=\>    #{id}   </foreach> </if>   </p><p>? 测试代码： </p><p> </p><p>List<Integer> ids = new ArrayList<Integer>();        </p><p>    </p><p>ids.add(1);//查询id为1的用户 ids.add(10);//查询id为10的用户 queryVo.setIds(ids); </p><p>List<User> list = userMapper.findUserList(queryVo); </p><p>javaEE框架课程   </p><p>4.4.3.2 传递单个List </p><p> </p><p>传递List类型在编写mapper.xml没有区别，唯一不同的是只有一个List参数时它的参数名为list。  </p><p>如下： </p><p>? Mapper.xml </p><p><selectid=\parameterType=\resultType=\ser\> </p><p>  select * from user   <where> </p><p>  <!-- 传递List，List中是pojo -->   <iftest=\> </p><p>  <foreachcollection=\item=\open=\in(\separator=\close=\>       #{item.id}    </foreach>   </if>   </where>  </select>  </p><p>? Mapper接口  </p><p>public List<User> selectUserByList(List userlist) throws Exception;  </p><p>? 测试： </p><p>Publicvoid testselectUserByList()throws Exception{                </p><p>               </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //构造查询条件List </p><p>List<User> userlist = new ArrayList<User>(); Useruser =new User(); user.setId(1); </p><p>userlist.add(user); user = new User(); user.setId(2); </p><p>userlist.add(user);  </p><p>//传递userlist列表查询用户列表 </p><p>List<User>list = userMapper.selectUserByList(userlist); //关闭session </p><p>javaEE框架课程   </p><p>    </p><p> } </p><p>session.close(); </p><p>4.4.3.3 传递单个数组（数组中是pojo）： </p><p>请阅读文档学习。 ? Mapper.xml  </p><p><!-- 传递数组综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\r\> </p><p>  select * from user   <where> </p><p>  <!-- 传递数组 --> </p><p>  <iftest=\> </p><p>  <foreachcollection=\index=\item=\open=\in(\separator=\close=\>       #{item.id}    </foreach>   </if>   </where>  </select> </p><p>sql只接收一个数组参数，这时sql解析参数的名称mybatis固定为array，如果数组是通过一个pojo传递到sql则参数的名称为pojo中的属性名。 index：为数组的下标。 </p><p>item：为数组每个元素的名称，名称随意定义 open：循环开始 close：循环结束 </p><p>separator：中间分隔输出  </p><p>? Mapper接口：  </p><p>public List<User> selectUserByArray(Object[] userlist) throws Exception;  </p><p>? 测试：  </p><p>Publicvoid testselectUserByArray()throws Exception{     </p><p>    </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); </p><p>javaEE框架课程   </p><p>              </p><p>            } </p><p>//构造查询条件List </p><p>Object[] userlist = new Object[2]; Useruser =new User(); user.setId(1); userlist[0]=user; user = new User(); user.setId(2); userlist[1]=user; </p><p>//传递user对象查询用户列表 </p><p>List<User>list = userMapper.selectUserByArray(userlist); //关闭session session.close(); </p><p>4.4.3.4 传递单个数组（数组中是字符串类型）： </p><p>请阅读文档学习。  </p><p>? Mapper.xml  </p><p><!-- 传递数组综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\r\> </p><p>  select * from user   <where> </p><p>  <!-- 传递数组 --> </p><p>  <iftest=\> </p><p>  <foreachcollection=\index=\item=\open=\in(\separator=\close=\>       #{item}    </foreach>   </if>   </where>  </select> </p><p>如果数组中是简单类型则写为#{item}，不用再通过ognl获取对象属性值了。 ? Mapper接口：  </p><p>public List<User> selectUserByArray(Object[] userlist) throws Exception;  </p><p>? 测试：  </p><p>Publicvoid testselectUserByArray()throws Exception{ </p><p>javaEE框架课程   </p><p>                 </p><p>            } </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //构造查询条件List </p><p>Object[] userlist = new Object[2]; userlist[0]=”1”; userlist[1]=”2”; </p><p>//传递user对象查询用户列表 </p><p>List<User>list = userMapper.selectUserByArray(userlist); //关闭session session.close(); </p><p>4.4.4 Sql片段 </p><p> </p><p>Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的，如下：  </p><p><!-- 传递pojo综合查询用户信息 --> </p><p> <selectid=\parameterType=\resultType=\>   select * from user   <where> </p><p>  <iftest=\>   and id=#{id}   </if> </p><p>  <iftest=\>   and username like '%${username}%'   </if>   </where>  </select>  </p><p>? 将where条件抽取出来：  </p><p><sqlid=\> </p><p> <iftest=\>   and id=#{id}  </if> </p><p> <iftest=\> </p><p>javaEE框架课程   </p><p>  and username like '%${username}%'  </if> </sql>  </p><p>? 使用include引用：  </p><p><selectid=\parameterType=\resultType=\>   select * from user   <where> </p><p>  <includerefid=\/>   </where>  </select>  </p><p>注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下： <includerefid=\namespace.sql片段”/>      </p><p>5 关联查询 </p><p> </p><p>javaEE框架课程   </p><p>5.1 商品订单数据模型 </p><p>外键：orders_id 订单表：orders 记录了用户创建的订单 创建用户:user_id(外键) 订单号 创建时间 订单状态 订单明细表：orderdetail 记录了用户购买信息 所属订单：orders_id（外键） 商品id:items_id（外键） 商品数量 商品购买价格 一对多 一个订单包括多个购买明细 一对一 一个订单明细只能 属于一个订单 外键： user_id 一对一： 一个订单只能由一个用户创建 一对一 一个明细对应一个商品 通过订单明细表订单表和商品表建立关系 一个订单对应多个商品 一个商品对应多个订单 订单表和商品表是多对多关系 外键： items_id 一对多 一个用户可以创建多个订单 一对多 一个商品对应多个订单明细 用户表：user 记录了购买商品的用户信息 Id：唯一标识一个用户 用户与订单是一对多 订单和商品是多对多 用户和商品是多对多 商品信息：items 记录了所有商品信息 商品id：id（主键） 商品名称： 商品介绍 商品价格  </p><p> </p><p>5.2 一对一查询 </p><p>案例：查询所有订单信息，关联查询下单用户信息。 </p><p>javaEE框架课程   </p><p> </p><p>注意：因为一个订单信息只会是一个人下的订单，所以从查询订单信息出发关联查询用户信息为一对一查询。如果从用户信息出发查询用户下的订单信息则为一对多查询，因为一个用户可以下多个订单。  </p><p>5.2.1 方法一： </p><p>使用resultType，定义订单信息po类，此po类中包括了订单信息和用户信息：  </p><p>5.2.1.1 Sql语句： </p><p> </p><p>SELECT    orders.*, user.username,   userss.address FROM   orders, user </p><p>WHERE orders.user_id = user.id   </p><p>5.2.1.2 定义po类 </p><p>Po类中应该包括上边sql查询出来的所有字段，如下：  </p><p>publicclass OrdersCustom extends Orders {  </p><p> private String username;// 用户名称  private String address;// 用户地址 get/set。。。。  </p><p>OrdersCustom类继承Orders类后OrdersCustom类包括了Orders类的所有字段，只需要定义用户的信息字段即可。  </p><p>javaEE框架课程   </p><p>5.2.1.3 Mapper.xml </p><p> </p><p><!-- 查询所有订单信息 --> </p><p> <selectid=\resultType=\tom\> </p><p> SELECT  orders.*, </p><p> user.username,  user.address  FROM  orders, user </p><p> WHERE orders.user_id = user.id   </select>  </p><p>5.2.1.4 Mapper接口： </p><p>public List<OrdersCustom> findOrdersList() throws Exception;  </p><p>5.2.1.5 测试： </p><p> </p><p>Publicvoid testfindOrdersList()throws Exception{            </p><p>       </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 </p><p>List<OrdersCustom> list = userMapper.findOrdersList(); System.out.println(list); </p><p> //关闭session  session.close(); } </p><p>5.2.1.6 总结： </p><p> 定义专门的po类作为输出类型，其中定义了sql查询结果集所有的字段。此方法较为简单，企业中使用普遍。 </p><p>javaEE框架课程   </p><p>5.2.2 方法二： </p><p>使用resultMap，定义专门的resultMap用于映射一对一查询结果。  </p><p>5.2.2.1 Sql语句： </p><p> </p><p>SELECT    orders.*, user.username, user.address FROM   orders, user </p><p>WHERE orders.user_id = user.id </p><p>5.2.2.2 定义po类 </p><p> 在Orders类中加入User属性，user属性中用于存储关联查询的用户信息，因为订单关联查询用户是一对一关系，所以这里使用单个User对象存储关联查询的用户信息。  </p><p>5.2.2.3 Mapper.xml </p><p><selectid=\resultMap=\>  SELECT  orders.*, </p><p> user.username,  user.address  FROM  orders, user </p><p> WHERE orders.user_id = user.id   </select>  </p><p>这里resultMap指定userordermap。  </p><p>javaEE框架课程   </p><p>5.2.2.4 定义resultMap </p><p>需要关联查询映射的是用户信息，使用association将用户信息映射到订单对象的用户属性中。 <!-- 订单信息resultmap --> </p><p><resultMaptype=\id=\> <!-- 这里的id，是mybatis在进行一对一查询时将user字段映射为user对象时要使用，必须写 --> </p><p><idproperty=\column=\/> </p><p><resultproperty=\column=\/> <resultproperty=\column=\/> </p><p><associationproperty=\javaType=\> <!-- 这里的id为user的id，如果写上表示给user的id属性赋值 --> <idproperty=\column=\/> </p><p><resultproperty=\column=\/> <resultproperty=\column=\/> </association> </resultMap> </p><p>association：表示进行关联查询单条记录 </p><p>property：表示关联查询的结果存储在cn.itcast.mybatis.po.Orders的user属性中 javaType：表示关联查询的结果类型 </p><p><idproperty=\column=\/>：查询结果的user_id列对应关联对象的id属性，这里是<id />表示user_id是关联查询对象的唯一标识。 </p><p><resultproperty=\column=\/>：查询结果的username列对应关联对象的username属性。  </p><p>5.2.2.5 Mapper接口： </p><p>public List<Orders> findOrdersListResultMap() throws Exception;  </p><p>5.2.2.6 测试： </p><p> </p><p>Publicvoid testfindOrdersListResultMap()throws Exception{        </p><p>       </p><p>//获取session </p><p>SqlSession session = sqlSessionFactory.openSession(); //获限mapper接口实例 </p><p>UserMapper userMapper = session.getMapper(UserMapper.class); //查询订单信息 </p><p>List<Orders> list = userMapper.findOrdersList2(); System.out.println(list); </p><p>javaEE框架课程   </p><p>    </p><p>  } </p><p>//关闭session session.close(); </p><p>5.2.2.7 小结： </p><p>使用association完成关联查询，将关联查询信息映射到pojo对象中。  </p><p>5.3 一对多查询 </p><p> </p><p>案例：查询所有订单信息及订单下的订单明细信息。  </p><p>订单信息与订单明细为一对多关系。  </p><p>使用resultMap实现如下：  </p><p>5.3.1 Sql语句： </p><p> </p><p>SELECT    orders.*, user.username, user.address, </p><p>  orderdetail.id orderdetail_id,   orderdetail.items_id,   orderdetail.items_num FROM </p><p>  orders,user,orderdetail  </p><p>WHERE orders.user_id = user.id  AND orders.id = orderdetail.orders_id  </p><p>5.3.2 定义po类 </p><p>在Orders类中加入User属性。 </p><p>在Orders类中加入List<Orderdetail> orderdetails属性 </p><p></p></div>

<p style='margin-top:7.8pt;margin-right:0cm;margin-bottom:12.45pt;margin-left:0cm;mso-para-margin-top:.5gd;mso-para-margin-right:0cm;mso-para-margin-bottom:.8gd;mso-para-margin-left:0cm;text-align:justify;text-justify:inter-ideograph;text-indent:32.0pt;mso-char-indent-count:2.0;line-height:24.0pt;mso-line-height-rule:exactly;mso-pagination:none'><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-family:"Times New Roman";mso-font-kerning:1.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoFooter align=center style='text-align:center'><span
style='font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";color:#993300'>南京廖华答案网</span><span lang=EN-US><a
href="http://www.32336.cn/">http://www.32336.cn/</a></span></p>

<p class=MsoFooter align=center style='text-align:center'><span
style='font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman";color:#993300'>免费文档下载</span><span lang=EN-US style='font-size:16.0pt;mso-bidi-font-size:10.0pt;color:#993300'><o:p></o:p></span></p>

</div></div>
</body></html>
